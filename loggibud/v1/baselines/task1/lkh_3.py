"""Implements the Lin-Kernighan-Helsgaun (LKH) solver
The solver used here is the LKH-3 version [1], which is able to solve CVRP
instances.

References
----------
    [1] https://github.com/cerebis/LKH3
"""
import logging
import os
import subprocess
from dataclasses import dataclass
from itertools import groupby
from typing import Optional

import numpy as np

from loggibud.v1.types import (
    CVRPInstance,
    CVRPSolution,
    CVRPSolutionVehicle,
    JSONDataclassMixin,
)
from loggibud.v1.data_conversion import to_tsplib


logger = logging.getLogger(__name__)


DEPOT_NODE = 1


@dataclass
class LKHParams(JSONDataclassMixin):
    # We need temporary file to interact with the LKH-3 C solver
    # This has parameters of the problem and it has the TSPLIB format
    input_vrp_file: str = "vrp_input_temp.vrp"

    # This file has parameters of the solver, as described in [1]
    input_par_file: str = "vrp_input_temp.par"

    # This file is the output file, which contains the output routes
    output_tour_file: str = "vrp_output_temp.vrp"

    # Time limit in seconds to step the solver
    time_limit_s: int = 60

    # Number of runs (as in a multistart heuristic)
    num_runs: int = 1


def solve(
    instance: CVRPInstance, params: Optional[LKHParams] = None
) -> CVRPSolution:
    """Solve a CVRP instance using LKH-3"""

    params = params or LKHParams()

    logger.info("Converting instance into a TSPLIB file")
    convert_instance_file(instance, params)

    logger.info("Calling LKH external solver")
    solve_lkh(instance, params)

    logger.info("Reading result from output files")
    solution = read_solution(instance, params)

    logger.info("Cleaning up temporary files")
    os.remove(params.input_vrp_file)
    os.remove(params.input_par_file)
    os.remove(params.output_tour_file)

    return solution


def convert_instance_file(instance: CVRPInstance, params: LKHParams) -> None:
    """
    The LKH-3 solver requires two files:
        - A .par file with parameters for the solver;
        - A .vrp file with information about the instance.
    The vrp file is created with the original TSPLIB format, and the .par one,
    which is specific for the LKH-3 solver, is created here.
    """

    to_tsplib(instance, file_name=params.input_vrp_file)

    # For the Asymetric CVRP, it only respects the capacity if the number of
    # vehicles is explicitly provided. Here, we use the same rule as the one
    # automatically adopted in the symmetric case
    total_demand = sum(delivery.size for delivery in instance.deliveries)
    num_vehicles = int(np.ceil(total_demand / instance.vehicle_capacity))
    with open(params.input_par_file, "w") as f:
        f.write(
            "SPECIAL\n"
            f"PROBLEM_FILE = {params.input_vrp_file}\n"
            "MTSP_OBJECTIVE = MINSUM\n"
            f"RUNS = {params.num_runs}\n"
            f"TOUR_FILE = {params.output_tour_file}\n"
            f"TIME_LIMIT = {params.time_limit_s}\n"
            f"VEHICLES = {num_vehicles}"
        )


def solve_lkh(instance: CVRPInstance, params: LKHParams) -> None:
    """Call the C solver and generate output files"""

    arguments = ("./loggibud/v1/baselines/task1/LKH", params.input_par_file)
    popen = subprocess.Popen(arguments, stdout=subprocess.PIPE)
    popen.wait()  # run the solver in the background


def read_solution(instance: CVRPInstance, params: LKHParams) -> CVRPSolution:
    """Read the files generated by the solver

    Notes
    -----
    The output is stored in a TSPLIB-like format. Here is a typical example.

    Suppose a problem with depot at node 1 and deliveries at 2, 3, 4, 5 and 6.
    Now, suppose the solution has two routes such as:
        - Route 1: [1, 2, 3]
        - Route 2: [1, 4, 5, 6]

    The output would be written in a file with the following:

        TOUR_SECTION
        1
        2
        3
        7 <---
        4
        5
        6
        -1

    The first node is 1, the depot, and the following are deliveries in the
    first route. Then, we reach a node 7, which is greater than all nodes in
    the problem. This actually marks the start of another route, and if we had
    more routes, it would be split with an 8, and so on.

    The reading goes on until a -1 is obtained, thus marking the end of all
    routes.

    Our reading process goes like:
        1. Read all output lines until the `TOUR_SECTION` begins;
        2. Read the nodes, converting each node larger than the number of
        locations into 1 until we reach a -1.
        3. The final list would be [1, 2, 3, 1, 4, 5, 6]. Then, split this
        list into subgroups with respect to the DEPOT_NODE 1, such as
        [2, 3], [4, 5, 6]. These will be the nodes of final routes.
    """

    num_locations = len(instance.deliveries) + 1
    with open(params.output_tour_file, "r") as f:
        # Ignore the header until we reach `TOUR_SECTION`
        for line in f:
            if line.startswith("TOUR_SECTION"):
                break

        # Read nodes in order replacing large numbers with DEPOT_NODE
        def read_delivery_nodes_gen():
            for line in f:
                node = int(line.rstrip("\n"))
                if node == -1:
                    break

                yield node if node <= num_locations else DEPOT_NODE

        all_route_nodes = list(read_delivery_nodes_gen())

        # Split the previous list with respect to `DEPOT_NODE`
        def write_route(nodes_group):
            # Notice the deliveries start at 2 in the output file but at 0 in
            # the instance
            deliveries = [
                instance.deliveries[node - 2] for node in nodes_group
            ]
            return CVRPSolutionVehicle(
                origin=instance.origin, deliveries=deliveries
            )

        nodes_groups = groupby(all_route_nodes, key=lambda x: x == DEPOT_NODE)
        routes = [
            write_route(nodes_group)
            for key, nodes_group in nodes_groups
            if not key
        ]

    return CVRPSolution(name=instance.name, vehicles=routes)
